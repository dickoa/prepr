---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  dev = "svg"
)
```

# prepair <img src="man/figures/hex-prepair.png" align="right" height="139" />

<!-- badges: start -->
[![GitLab CI Build Status](https://gitlab.com/dickoa/prepair/badges/master/pipeline.svg)](https://gitlab.com/dickoa/prepair/pipelines)
[![Codecov Code Coverage](https://codecov.io/gl/dickoa/prepair/branch/master/graph/badge.svg)](https://codecov.io/gl/dickoa/prepair)
[![CRAN status](http://www.r-pkg.org/badges/version/prepair)](http://www.r-pkg.org/pkg/prepair)
<!-- badges: end -->

An R package to repair broken GIS polygons using the [`prepair`](https://github.com/tudelft3d/prepair) Cpp library.

## Installation

The `prepair` Cpp library need these two libraries to compile:

- [`CGAL`](https://www.cgal.org/)
- [`GDAL`](https://gdal.org/)

The R package `prepair` solves the CGAL dependencies by using the [`cgal4headers`](https://gitlab.com/dickoa/cgal4headers) that expose CGAL 4 headers.
We use [`rwinlib`](https://github.com/rwinlib) to provide `GDAL` on Windows in order to build this package from source.

`prepair` can also use these optional libraries:

- [`GMP`](https://gmplib.org/)
- [`MPFR`](https://www.mpfr.org/)

They are disabled by default on Windows but required if you want to build the package in a Linux/OS X environment.
After installing all these libraries, you can now install the development version of the `prepair` R package from [Gitlab](https://gitlab.com/dickoa/prepair) using the `remotes` R package with:

```{r, eval = FALSE}
# install.packages("remotes")
remotes::install_gitlab("dickoa/prepair")
```

## A quick tutorial

This is a basic example which shows you how to solve a common problem:

### A 'bowtie' polygon:

```{r p1}
library(prepair)
library(sf)

p1 <- st_as_sfc("POLYGON((0 0, 0 10, 10 0, 10 10, 0 0))")
st_is_valid(p1, reason = TRUE)
p11 <- st_prepair(p1)
st_is_valid(p11)

st_as_text(p11)

par(mfrow = c(1, 2))
plot(p1, main = "RAW")
plot(p11, main = "Repaired")
```

### Square with wrong orientation:

```{r p2}
p2 <- st_as_sfc("POLYGON((0 0, 0 10, 10 10, 10 0, 0 0))")
st_is_valid(p2, reason = TRUE)
```

### Inner ring with one edge sharing part of an edge of the outer ring:

```{r p3}
p3 <- st_as_sfc("POLYGON((0 0, 10 0, 10 10, 0 10, 0 0),(5 2, 5 7, 10 7, 10 2, 5 2))")
st_is_valid(p3, reason = TRUE)
p33 <- st_prepair(p3)
st_is_valid(p33)

st_as_text(p33)

par(mfrow = c(1, 2))
plot(p3, main = "RAW")
plot(p33, main = "Repaired")
```

### Dangling edge:

```{r p4}
p4 <- st_as_sfc("POLYGON((0 0, 10 0, 15 5, 10 0, 10 10, 0 10, 0 0))")
st_is_valid(p4, reason = TRUE)
p44 <- st_prepair(p4)
st_is_valid(p44)

st_as_text(p44)

par(mfrow = c(1, 2))
plot(p4, main = "RAW")
plot(p44, main = "Repaired")
```

### Two adjacent inner rings:

```{r p6}
p6 <- st_as_sfc("POLYGON((0 0, 10 0, 10 10, 0 10, 0 0), (1 1, 1 8, 3 8, 3 1, 1 1), (3 1, 3 8, 5 8, 5 1, 3 1))")
st_is_valid(p6, reason = TRUE)
p66 <- st_prepair(p6)
st_is_valid(p66)

st_as_text(p66)

par(mfrow = c(1, 2))
plot(p6, main = "RAW")
plot(p66, main = "Repaired")
```

### Polygon with an inner ring inside another inner ring:
```{r p7}
p7 <- st_as_sfc("POLYGON((0 0, 10 0, 10 10, 0 10, 0 0), (2 8, 5 8, 5 2, 2 2, 2 8), (3 3, 4 3, 3 4, 3 3))")
st_is_valid(p7, reason = TRUE)
p77 <- st_prepair(p7)
st_is_valid(p77)

st_as_text(p77)

par(mfrow = c(1, 2))
plot(p7, main = "RAW")
plot(p77, main = "Repaired")
```

## A exemple with a real dataset

### Reading the data

```{r read_data, cache = TRUE}
(clc1 <- read_sf("https://github.com/tudelft3d/prepair/raw/master/data/CLC2006_180927.geojson"))
(clc2 <- read_sf("https://github.com/tudelft3d/prepair/raw/master/data/CLC2006_2018418.geojson"))
par(mfrow = c(1, 2))
plot(st_geometry(clc1), main = "CLC2006_180927", col = 'lightblue', axes = TRUE, graticule = TRUE, lwd = 0.2, cex.axis = 0.5)
plot(st_geometry(clc2), main = "CLC2006_2018418", col = "lightblue", axes = TRUE, graticule = TRUE, lwd = 0.2, cex.axis = 0.5)
```

### Check if it's valid and repair it

```{r clean_it, cache = TRUE}
st_is_valid(clc1, reason = TRUE)
(clc1_rpr <- st_prepair(clc1))
st_is_valid(clc1_rpr)

st_is_valid(clc2, reason = TRUE)
(clc2_rpr <- st_prepair(clc2))
st_is_valid(clc2_rpr)
```

### How fast is `st_prepair` ?

`prepair::st_prepair` is fast and can be in some cases faster than `sf::st_make_valid`

```{r bench, cache = TRUE}
(bnch1 <- bench::mark(st_make_valid(clc1), st_prepair(clc1), check = FALSE))
summary(bnch1, relative = TRUE)

(bnch2 <- bench::mark(st_make_valid(clc2), st_prepair(clc2), check = FALSE))
summary(bnch2, relative = TRUE)
```

You also have cases where it's slower to `sf::st_make_valid`, let's use this data from a [closed issue](https://github.com/r-spatial/sf/issues/1280) in the `sf` R package.

```{r new_data, cache = TRUE}
## need vsicurl
(agb <- read_sf("/vsicurl/http://files.hawaii.gov/dbedt/op/gis/data/2015AgBaseline.shp.zip"))
all(st_is_valid(agb))
all(st_is_valid(st_make_valid(agb)))
all(st_is_valid(st_prepair(agb)))

plot(st_geometry(agb), main = "2015 Agriculture baseline", col = 'lightblue', axes = TRUE, graticule = TRUE, lwd = 0.2, cex.axis = 0.5)
```

`sf::st_make_valid` is faster with this data.


```{r bench2, cache = TRUE}
(bnch3 <- bench::mark(st_make_valid(agb), st_prepair(agb), check = FALSE))
summary(bnch3, relative = TRUE)